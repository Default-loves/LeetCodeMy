### Description

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:

输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
示例 2:

输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
说明:

 n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/k-inverse-pairs-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### Solution

动态规划方法

设定`dp[i][j]`为包含从 1 到 i 的数字，且恰好拥有 j 个逆序对的不同的数组的个数

那么现在思考转移方程，从`i-1`过渡到`i`，被添加的数字`i`在数组中的位置会影响逆序对的个数。

对于`dp[i-1][j]=k`，即不同的数组个数为k个，对这k个数组在末尾添加一个数字`i`，被添加的数字`i`在所有数字中无疑是最大的，那么这k个数组的逆序对个数是不变的，仍然为`j`，即添加`i`后的这k个数组是`dp[i][j]`结果的一部分；如果在这k个数组添加数字`i`的位置在倒数第二个位，那么会导致这k个数组的逆序对个数加1，变为`j+1`，即添加`i`后的这k个数组是`dp[i][j+1]`的一部分，既然如此，那么如果我们在`dp[i-1][j-1]`的数组，添加数字`i`在倒数第二位，得到的逆序对个数则为`j`。

那么可以发现`dp[i][j]`是跟`dp[i-1][j]，dp[i-1][j-1]...`等有关，分别对应了添加的数字`i`位于`dp[i-1][j]`对应数组的末尾、`dp[i-1][j-1]`对应数组的倒数第二位，依次类推。

因此可以发现：

`dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i+1]`

不过这样的状态转移方程，时间复杂度是`O(N * K * K)`，可以优化一下。

将上式中的j替换为j-1可得下式：

`dp[i][j-1] = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i];`

通过将上述两个式子相减，可得：
`dp[i][j] - dp[i][j-1] = d[i-1][j] - dp[i-1][j-i];`

即：`dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i];`

时间复杂度：`O(N * K)`

空间复杂度：`O(N * K)`

```java
class Solution {
    private static final int INT = 1000000007;
    public int kInversePairs(int n, int k) {
        int[][] dp = new int[n+1][k+1];
        // 初始化
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k && j <= i * (i-1) / 2; j++) {
                // 特殊位置初始化
                if (j == 0) {
                    dp[i][j] = 1;	
                    continue;
                }
                // 下面这么做是为了避免溢出和产生负数
                int tmp = (dp[i-1][j] + INT - (j >= i? dp[i-1][j-i]: 0)) % INT;
                dp[i][j] = (tmp + dp[i][j-1]) % INT;
            }
        }
        return dp[n][k];
    }
}
```


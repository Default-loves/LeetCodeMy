### Description

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:

输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
示例 2:

输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
说明:

 n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/k-inverse-pairs-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### Solution

动态规划方法

设定`dp[i][j]`为包含从 1 到 i 的数字，且恰好拥有 j 个逆序对的不同的数组的个数

那么现在思考转移方程，对于`dp[i-1][j]`，即包含从 1 到 i-1 的数字，拥有的逆序对个数为j，而`dp[i][j]`是再添加一个数字`i`，那么被添加的数字`i`在所有数字中无疑是最大的，根据其在数组中的位置，会影响逆序对的个数。

如果`i`被添加在数组的末尾，对于`dp[i-1][j]`的那些数组，逆序对的个数不会改变，拥有`j`个逆序对的不同数组个数仍然为`dp[i-1][j]`；

如果`i`被添加在数组的头部，那么就会使数组增加`i-1`个逆序对，那么拥有`j`个逆序对的不同数组个数为`dp[i-1][j-i+1]`，对于中间情况也类似分析。因此可以发现：

`dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i+1]`

不过这样的状态转移方程，时间复杂度是`O(N * K * K)`，可以优化一下。

```java
dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i+1];
将上式中的j替换为j-1可得下式：
dp[i][j-1] = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i];
通过将上述两个式子相减，可得：
dp[i][j] - dp[i][j-1] = d[i-1][j] - dp[i-1][j-i];
即：
dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i];
```

时间复杂度：`O(N * K)`

空间复杂度：`O(N * K)`

```java
class Solution {
    private static final int INT = 1000000007;
    public int kInversePairs(int n, int k) {
        int[][] dp = new int[n+1][k+1];
        // 初始化
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k && j <= i * (i-1) / 2; j++) {
                // 特殊位置初始化
                if (j == 0) {
                    dp[i][j] = 1;	
                    continue;
                }
                // 下面这么做是为了避免溢出和产生负数
                int tmp = (dp[i-1][j] + INT - (j >= i? dp[i-1][j-i]: 0)) % INT;
                dp[i][j] = (tmp + dp[i][j-1]) % INT;
            }
        }
        return dp[n][k];
    }
}
```


### Description

在一个由 'L' , 'R' 和 'X' 三个字符组成的字符串（例如"RXXLRXRXL"）中进行移动操作。一次移动操作指用一个"LX"替换一个"XL"，或者用一个"XR"替换一个"RX"。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。

 

示例 :

输入: start = "RXXLRXRXL", end = "XRLXXRRLX"
输出: True
解释:
我们可以通过以下几步将start转换成end:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX


提示：

1 <= len(start) = len(end) <= 10000。
start和end中的字符串仅限于'L', 'R'和'X'。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/swap-adjacent-in-lr-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### Solution

这道题主要就是观察字符串的特点，通过理解题意我们发现，`L`只能往左移动，而`R`只能往右移动，并且将`X`替换为`""`后，两个字符串应该是一模一样的，可以认为`X`就是一个跳板，帮助字符移动

基于`L`只能往左移动这个特点，我们可以同时从左向右遍历两个字符串字符为`L`的索引，每次判断start字符串的索引`i`和end字符串的索引`j`，如果`i < j`，那么说明start[i]的`L`在end中的位置不符合，应该返回`false`，举个例子：

`start = XLX`，`end = XXL`

同时遍历两个数组，获取字符为`L`的索引，即`i=1, j=2`，由于`L`只能往左移动，你会发现不能从start变为end，即`i < j`的时候，返回`false`

同理对于`R`的情况也是同样的道理。

时间复杂度：`O(N)`

空间复杂度：`O(1)`

```java
class Solution {
    public boolean canTransform(String start, String end) {
        if (!start.replace("X", "").equals(end.replace("X", "")))
            return false;
        int i = 0, j = 0;
        while (i < start.length()) {
            while (i < start.length() && start.charAt(i) != 'L') i++;
            while (j < end.length() && end.charAt(j) != 'L') j++;
            if (i < j)
                return false;
            i++;j++;
        }
        i = 0; j = 0;
        while (i < start.length()) {
            while (i < start.length() && start.charAt(i) != 'R') i++;
            while (j < end.length() && end.charAt(j) != 'R') j++;
            if (i > j)
                return false;
            i++;j++;
        }
        return true;
    }
}
```


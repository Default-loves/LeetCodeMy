### Description

给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。

例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。

对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？

 

示例：

输入: words = ["time", "me", "bell"]
输出: 10
说明: S = "time#bell#" ， indexes = [0, 2, 5] 。


提示：

1 <= words.length <= 2000
1 <= words[i].length <= 7
每个单词都是小写字母 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/short-encoding-of-words
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### Thinking

字符串a需要是字符串b的后缀才可以压缩

使用一个List保存字符串，最后遍历List输出结果

### Solution

#### 简单法

```java
class Solution {
    public int minimumLengthEncoding(String[] words) {
        Arrays.sort(words, (s1, s2) -> s2.length()-s1.length());
        List<String> list = new ArrayList<>();
        for (int i = 0; i < words.length; i++) {
            boolean isInside = false;
            for (int j = 0; j < list.size(); j++) {
                if (isInside(list.get(j), words[i])){
                    isInside = true;
                    break;
                }
            }
            if (!isInside)
                list.add(words[i]);
        }
        int ans = 0;
        for (String s : list) {
            ans += s.length();
        }
        return ans + list.size();
    }

    private boolean isInside(String a, String b) {
        int i = 1;
        while (i <= b.length() && a.charAt(a.length()-i) == b.charAt(b.length()-i))
            i += 1;
        if (i == b.length()+1)
            return true;
        return false;
    }
}
```

#### 字典树

```java
class Solution {
    public int minimumLengthEncoding(String[] words) {
        Arrays.sort(words, (s1, s2) -> s2.length()-s1.length());
        Trie trie = new Trie();
        int res = 0;
        for (String word : words)
            res += trie.insert(word);
        return res;
    }
    class Trie {
        TrieNode root;
        public Trie() {
            root = new TrieNode(null);
        }
        public int insert(String s) {
            TrieNode cur = root;
            boolean isNew = false;
            for (int i = s.length()-1; i >= 0; i--) {
                char t = s.charAt(i);
                if (cur.child[t-'a'] == null) {
                    isNew = true;
                    cur.child[t-'a'] = new TrieNode(t);
                }
                cur = cur.child[t-'a'];
            }
            return isNew ? s.length()+1 : 0;
        }

        class TrieNode{
            char word;
            TrieNode[] child;
            public TrieNode(Character val) {
                word = val;
                child = new TrieNode[26];
            }
        }
    }
}
```

#### 翻转法

将每个字符串翻转后排序，那么“me”一定排在“time”的前面

```java
public int minimumLengthEncoding(String[] words) {
        int n = words.length;
        for (int i = 0; i < n; i++)
            words[i] = new StringBuilder(words[i]).reverse().toString();
        Arrays.sort(words);
        int ans = 0;
        for (int i = 0; i < n -1; i++) {
            if (!words[i+1].startsWith(words[i]))
                ans += words[i].length()+1;
        }
        ans += words[n -1].length()+1;
        return ans;
    }
```

#### 排序法

对于`"time", "me", "bell"`，排序后变为`"me", "time", "bell"`

```java
import static java.lang.Math.min;

class Solution {
    public int minimumLengthEncoding(String[] words) {
        int n = words.length;
        Comparator<String> cmp = (s1, s2) -> {
            int n1 = s1.length();
            int n2 = s2.length();
            for (int i = 1; i <= min(n1, n2); i++) {
                char c1 = s1.charAt(n1-i);
                char c2 = s2.charAt(n2-i);
                if (c1 != c2)
                    return c1 > c2 ? 1 : -1;
            }
            return n1 > n2 ? 1 : -1;
        };
        Arrays.sort(words, cmp);
        int ans = 0;
        for (int i = 0; i < n -1; i++) {
            if (!words[i+1].endsWith(words[i]))
                ans += words[i].length()+1;
        }
        ans += words[n -1].length()+1;
        return ans;
    }
}
```


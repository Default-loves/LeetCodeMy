题目：289. 生命游戏

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/game-of-life


### Description

根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。

```json
示例 1：
输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

示例 2：
输入：board = [[1,1],[1,0]]
输出：[[1,1],[1,1]]


提示：
m == board.length
n == board[i].length
1 <= m, n <= 25
board[i][j] 为 0 或 1
```


进阶：

你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？



### Solution

首先，如果我们遍历到`board[ i ][ j ]`并且进行了修改，当对其他格子比如`board[ i +1][j]`，统计周围8个格子存活细胞数量的时候，就丢失了`board[ i ][ j ]`原始的信息。而为了能够实现原地修改，不能创建新的数组来保存修改后的信息，因此只能修改原始信息

而我们发现每个格子的数值只是0或1，而java的int是32位的，我们可以用其他二进制位来表示修改后的信息。具体的，尾第一位用来表示原始信息，尾第二位用来表示修改后的信息，最终的时候需要将所有数据往右移动一位使修改后的信息覆盖原始信息

具体代码如下：

```java
class Solution {
    public void gameOfLife(int[][] board) {
        int[] dx = new int[]{-1, -1, -1, 0, 0, 1, 1, 1};    // dx和dy分别表示了周围的8个格子
        int[] dy = new int[]{1, 0, -1, 1, -1, 1, 0, -1};
        int n = board.length;
        int m = board[0].length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int count = 0;		// 统计周围8个格子的存活细胞个数
                for (int k = 0; k < 8; k++) {
                    int ix = i + dx[k];
                    int ij = j + dy[k];
                    if (ix >= 0 && ix < n && ij >= 0 && ij < m && (board[ix][ij] & 1) == 1) {      // 最后一位表示初始的细胞信息
                        count++;
                    }
                }
                if (board[i][j] == 1) {
                    if (count == 2 || count == 3) {
                        // 3的二进制为 11，尾第二位表示细胞存活
                        board[i][j] = 3;    
                    }
                    // 而对于细胞死亡的情况，board[i][j]还是1， 二进制为01，尾第二位为0表示细胞死亡，刚好不用处理
                } else if (count == 3){
                    board[i][j] = 2;    // 死细胞复活
                }
            }
        }
        // 尾第二位表示下一个状态的细胞情况，因此将全部数据向右移一位
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                board[i][j] >>= 1;
            }
        }
    }
}
```

